package Algorithms.Seminars.seminar_1;

// поиск простых чисел
public class Task_2B {

//    public static void Simple(int n) {
//        for (int num = 2; num <= n ; num++) {
//            boolean simple = true;
//            for (int p = 2; p < num; p++) {
//                if (num % p == 0) {
//                    simple = false;
//                    break;
//                }
//            }
//            if (simple) {
//                System.out.printf("%d ", num);
//            }
//        }
//    }
// сложность данного решения O(n) * O(n) = O(n^2) так как у нас два вложенных цикла

//    ускоряем данный код
    public static void Simple(int n) {
        for (int num = 2; num <= n ; num++) {
            boolean simple = true;
            for (int p = 2; p * p < num; p++) {
                if (num % p == 0) {
                    simple = false;
                    break;
                }
            }
            if (simple) {
                System.out.printf("%d ", num);
            }
        }
    }
// сложность данного решения  O(n * sqrt(n)).
// объяснение сложности
//Основной цикл `for` перебирает числа от 2 до n. Внутри основного цикла происходит второй цикл `for`, который
// проверяет, делится ли число на какое-либо другое простое число, меньшее, чем корень из числа num. Таким образом,
// для каждого числа num, второй цикл будет выполняться не более sqrt(num) раз, что и является причиной сложности
// алгоритма.
//В итоге, общее время выполнения алгоритма зависит от количества чисел, которые нужно проверить (n), а также от
// количества операций, необходимых для вычисления каждого простого числа.
// В результате получается сложность O(n * sqrt(n)).

    public static void main(String[] args) {
        Simple(100);
    }
}


// объяснение работы данного кода

//        Второй цикл `for` вложенный в первый цикл `for` работает корректно, несмотря на то, что при первой итерации
//        первого цикла переменная `num` имеет значение 2, а значит, второй цикл не должен выполняться.
//
//        В начале работы первого цикла `for` значение переменной `num` равно 2. При выполнении второго цикла `for`
//        переменная `p` начинает значение с 2, а затем каждый раз увеличивается на 1,
//        пока не достигнет значения `num-1`.
//
//        Итак, когда `num` имеет значение 2, то второй цикл `for` не выполнится ни разу, так как 2-1 = 1, и
//        для переменной `p` нет значений меньше 2, которые он может проверить.
//
//        При следующей итерации цикла `for`, когда `num` имеет значение 3, второй цикл начинается с `p=2`,
//        затем сравнивает число 3 с 2 и выясняет, что они не кратны друг другу. Затем значение `p`
//        увеличивается на 1 и становится равным 3, что больше, чем `num` на 1 (т.е. `3 >= 3-1`).
//        Второй цикл завершается и мы переходим к следующей итерации первого цикла.
//
//        Таким образом, второй цикл `for` работает правильно, и переменная `p` сперва начинает с 2, а затем
//        увеличивается на 1 при каждой следующей итерации, не превышая значение `num-1`.